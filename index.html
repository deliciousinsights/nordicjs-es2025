<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />

    <title>So, what‚Äôs new in ES2025? ‚Ä¢ Christophe Porteneuve @ Nordic.js 2022</title>

    <meta
      name="description"
      content="Yes, okay, ES2022 rules, and ES2015‚Äì2019 brought about a lot of cool things, but a ton of cool stuff is expected to land in the next few years, too‚Ä¶ and we can play with it already! Christophe takes you through a whirlwind tour of the upcoming features he‚Äôs most excited about, due to become official in 2023, 2024‚Ä¶ or 2025 ;-)"
    />
    <meta name="author" content="Christophe Porteneuve" />

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

    <link href="css/fonts.css" rel="stylesheet" type="text/css" />
    <link rel="stylesheet" href="css/reveal.css" />
    <link rel="stylesheet" href="css/animate.min.css" />
    <link rel="stylesheet" href="css/theme/sky.css" id="theme-basis" />
    <link rel="stylesheet" href="css/theme/pw15.css" id="theme" />

    <!-- Code syntax highlighting -->
    <link rel="stylesheet" href="lib/css/prism.css" />

    <!-- If the query includes 'print-pdf', include the PDF print sheet -->
    <script>
      if (window.location.search.match(/print-pdf/gi)) {
        var link = document.createElement('link')
        link.rel = 'stylesheet'
        link.type = 'text/css'
        link.href = 'css/print/pdf.css'
        document.getElementsByTagName('head')[0].appendChild(link)
      }
    </script>
  </head>

  <body id="prioFix">
    <div class="reveal">
      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">
        <section id="mainTitle">
          <h1>So, what‚Äôs new in ES2025?</h1>
          <p>
            A presentation by
            <a href="http://tddsworld.com/">Christophe Porteneuve</a> at
            <a href="https://nordicjs.com/2022">Nordic.js 2022</a>
          </p>
        </section>

        <section id="whoami">
          <h2>whoami</h2>

          <pre><code data-trim class="language-js">
const christophe = {
  family: { wife: 'üë©üèª‚Äçü¶∞ √âlodie', sons: ['üë¶üèª Maxence', 'üë¶üèª Elliott'] },
  city: 'Paris, FR',
  company: 'Delicious Insights',
  trainings: ['360¬∞ ES', 'Modern Web Apps', 'Node.js', '360¬∞ Git'],
  webDevSince: 1995,
  mightBeKnownFor: [
    'Prototype.js',
    'Prototype and Script.aculo.us (‚ÄúThe Bungie Book‚Äù)',
    'dotJS',
    'Paris Web',
    'NodeSchool Paris',
  ],
}
          </code></pre>
        </section>

        <section id="tc39">
          <h1>ES2025?!</h1>
          <h3>ECMA, TC39, ECMAScript and JavaScript</h3>
        </section>

        <section id="ecma">
          <h2>ECMA and TC39</h2>

          <p>
            ECMA is an international standards body<br />
            (like ISO, IETF, W3C or WHATWG, to name a few)
          </p>
          <p>ES = ECMAScript. The official standard for JavaScript*</p>
          <p>
            TC39 = Technical Committee 39. Caretaker of several standards:<br />
            ECMAScript (ECMA-262), <code>Intl</code> (ECMA-402), JSON (ECMA-404), etc.
          </p>

          <footer>
            * Which happens to be, in the U.S., a trademark of Oracle Corp. Yeah, I know ü§¢<br />
            This is why the community periodically discusses renaming the language to ‚ÄúJS‚Äù (and also to avoid Java HR
            confusion)
          </footer>
        </section>

        <section id="tc39-process-summary">
          <h2>The way the language evolves at TC39</h2>

          <p>Meetings every two months, mostly in the U.S.</p>
          <p><strong>Yearly cycle:</strong> feature freeze in January / March, formal release in June.</p>
          <p>‚ÄúES6‚Äù = ES2015, ‚ÄúES7‚Äù = ES2016, and now we say ES2022, etc.</p>
          <p>
            This is all
            <a href="https://github.com/tc39">transparent and public</a>.
          </p>
        </section>

        <section id="tc39-process-stages">
          <h2>
            The
            <a href="https://tc39.github.io/process-document/">5 stages</a> of the TC39 process
          </h2>

          <table class="condensed">
            <thead>
              <tr>
                <th>Stage</th>
                <th>Description</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <th>0¬†Strawman</th>
                <td>‚ÄúSay, it‚Äôd be nifty to get a Unicorn (ü¶Ñ) operator to‚Ä¶‚Äù</td>
              </tr>
              <tr class="fragment">
                <th>1¬†Proposal</th>
                <td>
                  A TC39 member becomes the proposal‚Äôs ‚Äúchampion.‚Äù The general shape of the API is defined, and most of
                  the
                  <em>cross-cutting concerns</em> are handled.
                </td>
              </tr>
              <tr class="fragment">
                <th>2¬†Draft</th>
                <td>The initial spec text is done, and covers all critical aspects and the tech semantics.</td>
              </tr>
              <tr class="fragment">
                <th>3¬†Candidate</th>
                <td>
                  The spec is complete, duly reviewed and approved. The API is finalized and no stone is left unturned.
                </td>
              </tr>
              <tr class="fragment">
                <th>4¬†Finished</th>
                <td>
                  Full Test262 coverage, 2+ shipped implementations (usually v8 and Spidermonkey), significant
                  real-world feedback, and imprimatur by the Spec Editor. Will then be part of the next feature freeze
                  (January-March), hence ship in the associated yearly release.
                </td>
              </tr>
            </tbody>
          </table>
        </section>

        <section id="our-story-so-far">
          <h1>Quick recap: ES2020‚Äì2022</h1>
          <h2>A curated list of stuff too many people missed üòâ</h2>
        </section>

        <section id="es2020-matchAll">
          <h2>ES2020: <code>String</code>#<code>matchAll</code></h2>

          <p>Grabs <strong>all group matches</strong> for a <em>sticky</em> or global regex.</p>

          <pre><code class="language-js">
            const text = 'Get in touch at tel:0983450176 or sms:478-555-1234'

            text.<u>match</u>(/<u>(</u>?&lt;protocol>[a-z]{3}<u>)</u>:<u>(</u>?&lt;number>[\d-]+<u>)</u>/<u>g</u>)
            // => ['tel:0983450176', 'sms:478-555-1234'] -- üòû WHERE THEM GROUPS AT?!
          </code></pre>

          <pre class="fragment"><code class="language-js">
            Array.from(text.<u>matchAll</u>(/([a-z]{3}):([\d-]+)/g)).map(
              ([, protocol, number]) => ({ protocol, number })
            )
            // => [{ number: '0983450176', protocol: 'tel' }, { number: '478-555-1234', protocol: 'sms' }]

            Array.from(text.<u>matchAll</u>(/(?&lt;protocol>[a-z]{3}):(?&lt;number>[\d-]+)/g)).map((mr) => mr.groups)
            // => [{ number: '0983450176', protocol: 'tel' }, { number: '478-555-1234', protocol: 'sms' }]
          </code></pre>
        </section>

        <section id="es2020-allsettled">
          <h2>ES2020 / ES2021: <code>Promise.allSettled</code>/<code>any</code></h2>

          <p>
            The two final combinators; <code>any</code> short-circuits on <strong>first fulfillment</strong>.
            <code>allSettled</code> doesn‚Äôt short-circuit, be it on the first rejection or fulfillment: we get all
            settlements for analysis.
          </p>

          <p>
            With ES2015‚Äôs <code>all</code> (short-circuits on first rejection) and <code>race</code> (first settlement),
            we now cover all use-cases.
          </p>

          <pre><code class="language-js">
            // May the fastest successful fetch win!
            const data = await <u>Promise.any</u>([fetchFromDB(), fetchFromHighSpeedLAN()])

            // Run tests in parallel, but don't short-circuit!
            await <u>Promise.allSettled</u>(tests)
            // => [
            //   { status: 'fulfilled', value: Response‚Ä¶ },
            //   { status: 'fulfilled', value: undefined },
            //   { status: 'rejected', reason: Error: snapshot‚Ä¶ }
            // ]
          </code></pre>
        </section>

        <section id="es2022-class-fields">
          <h2>ES2022: Class fields</h2>

          <p>Static and instance field initializers + everything can be <strong>actually</strong> private</p>

          <pre><code class="language-js">
            class APIClient extends Fetcher {
              // Private instance field
              <u>#oauthToken =</u> null
              // Public static field
              <u>static VERSION</u> = process.env.API_CLIENT_VERSION
              // Public instance field
              <u>state =</u> { authenticated: this.#oauthToken != null, loggedIn: false }
              // Private instance method
              <u>#shareAuthWith</u>(recipient) {
                // Requires that `recipient` be an `APIClient`
                recipient.#oauthToken = this.#oauthToken
              }
            }
          </code></pre>
        </section>

        <section id="es2022-static-blocks">
          <h2>ES2022: Static blocks</h2>

          <p>Single-pass multi-static-field init, private static init, and more‚Ä¶</p>

          <pre><code class="language-js">
            class Translator {
              static translations = { yes: 'ja', no: 'nej', maybe: 'kanske' }
              static englishWords = []
              static swedishWords = []
              <u>static {</u>
                // There! We can initialize both fields with a single operation,
                // instead of duplicating the computation.

                for (const [english, swedish] of Object.entries(this.translations)) {
                  this.englishWords.push(english)
                  this.swedishWords.push(swedish)
                }
              <u>}</u>
            }
          </code></pre>

          <footer>h/t Dr. Axel Rauschmayer (@rauschma / 2ality.net) for the example</footer>
        </section>

        <section id="es2022-iterable-at">
          <h2>ES2022: <code>at()</code> on built-in iterables ü§©</h2>

          <p>
            You know how <code>Array</code> and <code>String</code> let you use negative indices with
            <code>slice</code>, <code>splice</code>, etc. but can't let you use them with <code>[‚Ä¶]</code>? This makes
            getting the last item particularly irritating.
          </p>

          <p>
            Well now <strong>every built-in iterable</strong> gets a <code>.at(‚Ä¶)</code> method allowing negative
            indices!
          </p>

          <pre><code class="language-js">
            const cities = ['Stockholm', 'G√∂teborg', 'Malm√∂', 'V√§ster√•s']
            cities<u>.at(-1)</u> // => 'V√§ster√•s'
            cities<u>.at(-2)</u> // => 'Malm√∂'
          </code></pre>
        </section>

        <section id="es2022-object-hasown">
          <h2>ES2022: <code>Object.hasOwn()</code></h2>

          <p>
            It's long been a recommended best practice to check own-property existence with the rather long-winded code
            below, to circumvent ill-advised implementation overrides:
          </p>

          <pre><code class="language-js">
            const olga = { givenName: 'Olga', familyName: 'Stern', emcee: true }
            Object.prototype.hasOwnProperty.call(olga, 'emcee') // => true üòÆ‚Äçüí®
          </code></pre>

          <p>We finally have a shortcut:</p>

          <pre><code class="language-js">
              <u>Object.hasOwn</u>(olga, 'emcee') // => true
          </code></pre>
        </section>

        <section id="es2023">
          <h1>ES2023</h1>
          <h2>(guaranteed or likely)</h2>

          <footer>
            There is just <strong>too much stuff</strong> for me to illustrate everything in 30 minutes, especially
            considering I want to highlight post-2023 stuff, so this is a <strong>curated</strong> list.
          </footer>
        </section>

        <section id="es2023-find-from-last">
          <h2>ES2023: Find from last üòô</h2>

          <p>
            <code>Array</code>‚Äôs had <code>find</code> and <code>findIndex</code> for a while now (ES2015), but what
            about searching <strong>from the end</strong>?<br />
            After all, we‚Äôve long had <code>reduceRight</code> and <code>lastIndexOf</code>, right?
          </p>

          <p>
            We used to have to either roll our own loops üòî or get ham-handed with a prior (mutable!)
            <code>reverse()</code>, but no longer!
          </p>

          <pre><code class="language-js">
            const codeInTheDarkLeaderboard = [
              { id: 'Bart', score: 91, firstTime: false },
              { id: 'Lisa', score: 102, firstTime: true },
              { id: 'Homer', score: 115, firstTime: true },
              { id: 'Marge', score: 138, firstTime: false },
            ]

            const bestFirstTimer = codeInTheDarkLeaderboard.<u>findLast</u>(({ firstTime }) => firstTime)
            // => { id: 'Homer', score: 115, firstTime: true }
            const bestUsualIndex = codeInTheDarkLeaderboard.<u>findLastIndex</u>(({ firstTime }) => !firstTime)
            // => 3
          </code></pre>
        </section>

        <section id="es2023-hashbang">
          <h2>ES2023: Hashbang grammar</h2>

          <p>
            Behold! Universal JavaScript takes another step forward, with the official allowance for hashbangs at the
            top of source text.
          </p>

          <pre><code class="language-js">
            <u>#! /usr/bin/env node</u>

            if (detectCLIUse()) {
              runCLI()
            }

            // Internals and exports here‚Ä¶

            function runCLI() { ‚Ä¶ }
          </code></pre>
          <!-- https://github.com/tc39/proposal-hashbang#readme -->
        </section>

        <section id="es2023-temporal">
          <h2>ES2023: Temporal ü•≥ <span class="stage" title="Stage 3">3</span></h2>

          <p>Aims to (beneficially) replace Moment, Luxon, date-fns, etc.</p>
          <p>Immutable, nanosecond-precise, has all TZ, distinguishes absolute vs. local, explicit‚Ä¶</p>
          <p>Great complement to <code>Intl</code> and its formatting functions.</p>

          <pre><code class="language-js">
            const meeting1 = Temporal.Date.from('2020-01-01')
            const meeting2 = Temporal.Date.from('2020-04-01')
            const time = Temporal.Time.from('10:00:00')
            const timeZone = new Temporal.TimeZone('America/Montreal')

            const absolute1 = timeZone.getAbsoluteFor(meeting1.withTime(time))
            // => 2020-01-01T15:00:00.000Z
            const absolute2 = timeZone.getAbsoluteFor(meeting2.withTime(time))
            // => 2020-01-01T14:00:00.000Z
          </code></pre>

          <p>
            Check out <a href="https://tc39.es/proposal-temporal/docs/">the docs</a>,
            <a href="https://tc39.es/proposal-temporal/docs/cookbook.html">the cookbook</a>
            and
            <a href="https://www.dotconferences.com/2019/12/maggie-johnson-pint-making-time-make-sense"
              >Maggie‚Äôs awesome talk at dotJS 2019</a
            >!
          </p>

          <!-- https://tc39.es/proposal-temporal/docs/ -->
        </section>

        <section id="es2023-array-grouping">
          <h2>ES2023: Array grouping üéâ <span class="stage" title="Stage 3">3</span></h2>

          <p>One less reason to use Lodash, eh?</p>

          <pre><code class="language-js">
            const schedule = [
              { label: 'Registration & Coffee', time: '08:01', type: 'hallway' },
              { label: 'Opening', time: '09:30', type: 'stage' },
              { label: 'So, what‚Äôs new in ES2025?', time: '09:40', type: 'stage' },
              { label: 'Evolving your Design System through Data', time: '10:15', type: 'stage' },
              // ‚Ä¶
            ]
            <u>schedule.group</u>(({ type }) => type)
            // {
            //   hallway: [{ label: 'Registration‚Ä¶' }],
            //   stage: [{ label: 'Opening'‚Ä¶ }, { label: 'So, what‚Äôs‚Ä¶'‚Ä¶ }, { label: 'Evolving‚Ä¶'‚Ä¶ }]
            // }

            <u>schedule.groupToMap</u>(({ type }) => type)
            // => Same **as a Map** (so ANY KEY TYPE!)
          </code></pre>
        </section>

        <section id="es2023-import-assertions">
          <h2>ES2023: Import assertions + JSON modules <span class="stage" title="Stage 3">3</span></h2>

          <p>Provides additional info on imports using inline syntax.</p>
          <p>
            First, long-discussed use-case is allowing extra module types with an explicit type expectation to
            strengthen security (sort of like HTTP‚Äôs <code>X-Content-Type-Options: nosniff</code> safeguard).
          </p>

          <pre><code class="language-js">
            // Static imports
            import config from '../config/config.json' <u>assert { type: 'json' }</u>

            // Dynamic imports
            const { default: config } = await import('../config/config.json'<u>, { assert: { type: 'json' } }</u>)
          </code></pre>

          <p>The spec suggests related updates to Web Worker instantiation and HTML‚Äôs <code>script</code> tag.</p>
        </section>

        <section id="es2023-reg-exp-v-flag">
          <h2>ES2023: RegExp v flag <span class="stage" title="Stage 3">3</span></h2>

          <p>
            Allows <strong>nested classes</strong> (classes are character sets), which enables
            <strong>difference</strong> and <strong>intersection</strong> of classes. Very cool.
          </p>

          <p>Use as a replacement for the <code>u</code> (Unicode) flag when you need that capability.</p>

          <pre><code class="language-js">
            // All Unicode decimal digits, except for ASCII ones:
            text.match(/[\p{Decimal_Number}<u>--</u>[0-9]]/g<u>v</u>)

            // All Khmer letters (so both Khmer script AND letter property)
            text.match(/[\p{Script=Khmer}<u>&&</u>\p{Letter}]/g<u>v</u>)
          </code></pre>
        </section>

        <section id="es2023-duplicate-named-capture-groups">
          <h2>ES2023: Duplicate named capture groups <span class="stage" title="Stage 3">3</span></h2>

          <p>
            Named capture groups (ES2018) boosted regex readability, but they erroneously forbid name re-use, even in
            distinct parts of an alternative üòî
          </p>

          <p>
            Still Test262-incomplete, but a reasonsably minor update, the odds are good that it'll make the next feature
            freeze‚Ä¶ if native engines implement it before then.
          </p>

          <pre><code class="language-js">
            const year = dateText.match(/(<u>?&lt;year</u>>[0-9]{4})-[0-9]{2}<u>|</u>[0-9]{2}-(<u>?&lt;year></u>[0-9]{4})/)?.groups.year
          </code></pre>
        </section>

        <section>
          <h1>üîÆ Looking farther‚Ä¶ üîÆ</h1>
        </section>

        <section id="change-array-by-copy">
          <h2>Change array by copy <span class="stage" title="Stage 3">3</span></h2>

          <p>
            A set of extra helpers for deriving arrays. The <code>Array</code> API currently (2022) has 8 derivative
            methods (producing a new array) vs. 9 mutative ones (altering the original array), including
            <code>reverse()</code> and <code>sort()</code>, which most people expect not to be mutative!
          </p>

          <pre><code class="language-js">
            const fridayMorningSpeakers = ['Colin', 'Jessy', 'Jenn', 'Charlie']

            fridayMorningSpeakers<u>.toReversed</u>() // => ['Charlie', 'Jenn', 'Jessy', 'Colin']
            fridayMorningSpeakers<u>.toSorted</u>() // => ['Charlie', 'Colin', 'Jenn', 'Jessy']
            fridayMorningSpeakers<u>.toSpliced</u>(-2, 2) // => ['Jenn', 'Charlie']
            fridayMorningSpeakers<u>.with</u>(-2, 'Creighton') // => ['Colin', 'Jessy', 'Creighton', 'Charlie']

            fridayMorningSpeakers // => ['Colin', 'Jessy', 'Jenn', 'Charlie']
          </code></pre>
        </section>

        <section id="decorators">
          <h2>Decorators <span class="stage" title="Stage 3">3</span></h2>

          <p>
            It's been on the table forever and is still Test262-incomplete, but is being worked on, so we'll get it
            eventually (also, decorators are super-popular on the TypeScript side, so the demand is clear).
          </p>

          <p>So much nicer for AOP‚Ä¶ ES provides the plumbing and the ecosystem provides operational decorators.</p>

          <pre><code class="language-js">
            class SuperWidget extends Component {
              <u>@deprecate</u>
              deauth() { ‚Ä¶ }

              <u>@memoize('1m')</u>
              userFullName() { ‚Ä¶ }

              <u>@autobind</u>
              logOut() {
                this.#oauthToken = null
              }

              <u>@override</u>
              render() { ‚Ä¶ }
            }
          </code></pre>
        </section>

        <section id="shadow-realms">
          <h2>Shadow Realms <span class="stage" title="Stage 3">3</span></h2>

          <p>
            The groundwork for full control of sandboxed JS evaluation, tuning the global environment and available JS
            built-ins.
          </p>

          <p>
            A godsend for Web-based IDEs, DOM virtualization, test frameworks, safe end-user scripting capability,
            server-side rendering, and more!
          </p>

          <pre><code class="language-js">
            const realm = new ShadowRealm()

            const process = await realm.importValue('./utils/processor.js', 'process')
            const processedData = process(data)

            // Actual isolation!
            globalThis.userLocation = 'Stockholm, Sverige'
            realm.evaluate('globalThis.userLocation = "Paris, France"')
            globalThis.userLocation // => 'Stockholm, Sverige'
          </code></pre>

          <p>
            See <a href="https://github.com/tc39/proposal-shadowrealm/blob/main/explainer.md">this explainer</a> for
            details.
          </p>
        </section>

        <section id="collection-stuff">
          <h2>Tons of collection / iterator stuff <span class="stage" title="Stage 2">2</span></h2>

          <p>
            We'll always be operating on collections and iterables in general, so we might as well beef up the standard
            library‚Ä¶
          </p>

          <p>
            <a href="https://github.com/tc39/proposal-set-methods#readme">Many new <code>Set</code> methods</a>
            (intersection, union, difference, disjunction, sub/superset, etc.),
            <a href="https://github.com/tc39/proposal-iterator-helpers#readme">built-in iterator helpers</a> (instead of
            having to write stuff like <code>take</code>, <code>filter</code> or <code>map</code> as generative
            functions), <a href="https://github.com/tc39/proposal-upsert#readme"><code>Map#emplace()</code></a>
            for upserting in maps, and even
            <a href="https://github.com/tc39/proposal-collection-normalization#readme">collection normalization</a> are
            all at stage 2 and moving fast.
          </p>

          <pre><code class="language-js">
            function* fibonacci() { /* ‚Ä¶ */ }

            const firstTens = new Set([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
            const fibs = new Set(fibonacci()<u>.take</u>(10))
            const earlyFibs = firstTens<u>.intersection</u>(fibonacci) // => Set { 1, 2, 3, 5, 8 }
            const earlyNonFibs = firstTens<u>.difference</u>(fibonacci) // => Set { 4, 6, 7, 9, 10 }
            const evenFibs = earlyFibs.values()<u>.filter</u>((n) => n % 2 === 0)

            const headers = new Map(undefined, <u>{
              coerceKey: (name) => name.toLowerCase()
            }</u>)
            headers.set('X-Requested-With', 'politeness')
            headers // => Map { 'x-requested-with': 'politeness' }
          </code></pre>
        </section>

        <section id="records-tuples">
          <h2>Records &amp; Tuples <span class="stage" title="Stage 2">2</span></h2>

          <p><strong>IMMUTABILITY FOR THE WIN! üí™üèª</strong></p>

          <p>
            Native deeply-immutable objects (records) and arrays (tuples). Helps bring about all the benefits of
            immutability (e.g. referential identity), helps furthering functional JS programming.
          </p>

          <p>
            All usual operators and APIs apply (<code>in</code>, <code>Object.keys()</code>, <code>Object.is()</code>,
            <code>===</code>, etc.), and it plays nice with the standard library. Conversion from mutables is made easy
            through factories. Also, <code>JSON.parseImmutable()</code>!
          </p>

          <pre><code class="language-js">
            // Records
            const emma1 = #{ given: 'Emma', family: 'Bostian' }
            const emma2 = #{ given: 'Emma', family: 'Twersky' }
            const emma3 = #{ ...emma2, family: 'Bostian' }

            emma1 === emma3 // => true!
            Object.keys(emma1) // => ['family', 'given'] -- sorted!

            // Tuples
            #[1, 2, 3] === #[1, 2, 3] // => true!
          </code></pre>

          <p>
            <strong
              >Try the neat <a href="https://tc39.es/proposal-record-tuple/tutorial/">tutorial</a>, the cool
              <a
                href="https://rickbutton.github.io/record-tuple-playground/#eyJjb250ZW50IjoiLy8gSGkgTm9yZGljLmpzIGF0dGVuZGVlISA6LURcblxuLy8gUmVjb3Jkc1xuY29uc3QgZW1tYTEgPSAjeyBnaXZlbjogJ0VtbWEnLCBmYW1pbHk6ICdCb3N0aWFuJyB9XG5jb25zdCBlbW1hMiA9ICN7IGdpdmVuOiAnRW1tYScsIGZhbWlseTogJ1R3ZXJza3knIH1cbmNvbnN0IGVtbWEzID0gI3sgLi4uZW1tYTIsIGZhbWlseTogJ0Jvc3RpYW4nIH1cblxuY29uc29sZS5sb2coZW1tYTEgPT09IGVtbWEzKVxuY29uc29sZS5sb2coT2JqZWN0LmtleXMoZW1tYTEpKVxuXG4vLyBUdXBsZXNcbmNvbnNvbGUubG9nKCNbMSwgMiwgM10gPT09ICNbMSwgMiwgM10pIiwic3ludGF4IjoiaGFzaCIsImRvbU1vZGUiOmZhbHNlfQ=="
                >playground</a
              >
              and the amazing <a href="https://tc39.es/proposal-record-tuple/cookbook/">cookbook</a>!</strong
            >
          </p>
        </section>

        <section id="pipeline-operator">
          <h2>Pipeline operator <span class="stage" title="Stage 2">2</span></h2>

          <p>Tidies up processing chains that used to be nested function calls / interpolations / arithmetic / etc.</p>
          <p>
            Especially useful with unbound iterator helpers (e.g. Ramda functions). Placeholder syntax (<code>%</code>)
            is still subject to change.
          </p>

          <div class="two-columns">
            <div>
              <pre><code class="language-js">
                // BEFORE ü§Æ
                console.log(
                  chalk.dim(
                    `$ ${Object.keys(envars)
                      .map(envar =>
                        `${envar}=${envars[envar]}`)
                      .join(' ')
                    }`,
                    'node',
                    args.join(' ')))

                const result = Array.from(
                  take(3,
                    map((v) => v + 1,
                      filter((v) => v % 2 === 0, numbers))))
              </code></pre>
            </div>
            <div>
              <pre><code class="language-js">
                // AFTER
                Object.keys(envars)
                  .map(envar => `${envar}=${envars[envar]}`)
                  .join(' ')
                  <u>|></u> `$ ${<u>%</u>}`
                  <u>|></u> chalk.dim(<u>%</u>, 'node', args.join(' '))
                  <u>|></u> console.log(<u>%</u>)


                const result = numbers
                  <u>|></u> filter(<u>%</u>, (v) => v % 2 === 0)
                  <u>|></u> map(<u>%</u>, (v) => v + 1)
                  <u>|></u> take(<u>%</u>, 3)
                  <u>|></u> Array.from
              </code></pre>
            </div>
          </div>
        </section>

        <section id="object-pick-omit">
          <h2><code>Object.pick()</code> / <code>omit()</code> ü§© <span class="stage" title="Stage 1">1</span></h2>

          <p>
            It's about time we didn't need Lodash for that. Very recent proposal (July 2022). Allows for key sets or
            predicate callback (with optional <code>this</code> specifier).
          </p>

          <pre><code class="language-js">
            const conference = { name: 'Nordic.js', year: 2022, city: 'Stockholm', speakers: 21 }
            <u>Object.pick</u>(conference, ['name', 'year'])
            // => { name: 'Nordic.js', year: 2022 }

            <u>Object.pick</u>(conference, (value) => typeof value === 'number')
            // => { year: 2022, speakers: 21 }

            <u>Object.omit</u>(conference, (value) => typeof value === 'number')
            // => { name: 'Nordic.js', city: 'Stockholm' }
          </code></pre>

          <p>It <em>might</em> get even further, with syntatic sugar for key lists in picking:</p>

          <pre><code class="language-js">
            conference<u>.{name, year}</u> // => { name: 'Nordic.js', year: 2022 }

            const keys = ['name', 'city']
            conference<u>.[...keys]</u>
            // => { name: 'Nordic.js', city: 'Stockholm' }
          </code></pre>
        </section>

        <section id="extended-regexps">
          <h2>Extended-mode regular expressions üéâ <span class="stage" title="Stage 1">1</span></h2>

          <p>
            After Perl, .NET, Ruby‚Ä¶ JS finally gets an extended-mode regex syntax. Allows for non-significant whitespace
            (including line breaks within <code>RegExp</code> constructor arguments) and comments (inline or line).
            Readability FTW!
          </p>

          <pre><code class="language-js">
            const TAG_REGEX = new RegExp(String.raw`
              <
              <u># Tag name</u>
              (?&lt;tag>[\w-]+)
              \s+
              <u># Attributes</u>
              (?&lt;attrs>.+?)
              >
              <u># Contents</u>
              (?&lt;content>.+?)
              <u># Closing tag</u>
              &lt;/\k&lt;tag>>
            `, <u>'x'</u>)
          </code></pre>

          <footer>
            This was last presented a year ago (Oct 21). You can also use inline comments in regular expression
            literals. It would be lovely to get regular expression syntax coloration in constructor arguments using a
            VSCode extension and custom tagged template literal. üòâ
          </footer>
        </section>

        <section id="policy-maps-sets">
          <h2>Policy maps and sets üòé <span class="stage" title="Stage 1">1</span></h2>

          <p>
            These collections are often used with a need for <strong>capped capacity</strong>. This implies an
            <strong>eviction strategy</strong>: LIFO, FIFO, MRU, LRU‚Ä¶ This is all usually implemented by hand through
            wrapper functions. How about having it built-in?
          </p>

          <p>
            We may get
            {<code>FIFO</code>,<code>LIFO</code>,<code>MRU</code>,<code>LRU</code>}{<code>Map</code>,<code>Set</code>}
            if this proposal makes it through!
          </p>

          <footer>
            (Again, a July 2022 proposal, but this is not super heavy and should get there before 2025 üòâ)
          </footer>
        </section>

        <section id="pattern-matching">
          <h2>Pattern matching ü§Ø <span class="stage" title="Stage 1">1</span></h2>

          <p>
            <code>match </code> expression, which provides sort of structure-based switching. Similar features in Rust,
            Python, F#, Elixir/Erlang‚Ä¶ Just <strong>skimming the surface</strong> of what is envisioned here:
          </p>

          <pre><code class="language-js">
            <u>match (res) {</u>
              <u>when ({ status: 200, body, ...rest }):</u> handleData(body, rest)
              <u>when ({ status, destination: url }) if (300 &lt;= status && status &lt; 400):</u>
                handleRedirect(url)
              <u>when ({ status: 500 }) if (!this.hasRetried):</u> do {
                retry(req)
                this.hasRetried = true
              }
              <u>default:</u> throwSomething()
            <u>}</u>

            const commandRsult = <u>match (command) {</u>
              <u>when ([ 'go', dir and ('north' or 'east' or 'south' or 'west')]):</u> go(dir);
              <u>when ([ 'take', item and /[a-z]+ ball/ and { weight }]):</u> take(item);
              <u>default:</u> lookAround()
            }
          </code></pre>

          <footer>Last presented March 2022 (as of October 2022).</footer>
        </section>

        <section id="screencasts">
          <h2>Do you like cool video courses?</h2>

          <p>We publish about one new video course every month, mostly around Git and JS.</p>

          <br />
          <h4>
            <code
              ><a href="https://screencasts.delicious-insights.com/?coupon=NORDICJS"
                >screencasts.delicious-insights.com/?coupon=NORDICJS</a
              ></code
            >
          </h4>
          <p>(50% off on all courses for you folks!)</p>

          <p>Or if that‚Äôs easier for you:</p>

          <br />

          <h3>
            <code><a href="https://bit.ly/screencasts-nordicjs">bit.ly/screencasts-nordicjs</a></code>
          </h3>
        </section>

        <section id="thank-you">
          <h1>Tack!</h1>
          <h3>Satsa alltid p√• JS.</h3>
          <br />
          <p>Christophe Porteneuve</p>
          <p><a href="https://twitter.com/porteneuve">@porteneuve</a></p>

          <h2 class="breathing">
            Slides are at
            <code><a href="https://bit.ly/nordicjs-es2025">bit.ly/nordicjs-es2025</a><br /></code>
          </h2>
        </section>
      </div>
    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="plugin/highlight/prism.js"></script>
    <script src="js/reveal.js"></script>

    <script>
      // Full list of configuration options available here: // https://github.com/hakimel/reveal.js#configuration
      /* global Reveal */
      Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: true,

        width: '95%',
        height: '90%',

        theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
        transition: Reveal.getQueryHash().transition || 'linear', // default/cube/page/concave/zoom/linear/fade/none

        // Parallax scrolling
        // parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg',
        // parallaxBackgroundSize: '2100px 900px',

        // Optional libraries used to extend on reveal.js
        dependencies: [
          {
            src: 'lib/js/classList.js',
            condition: function () {
              return !document.body.classList
            },
          },
          {
            src: 'plugin/markdown/marked.js',
            condition: function () {
              return !!document.querySelector('[data-markdown]')
            },
          },
          {
            src: 'plugin/markdown/markdown.js',
            condition: function () {
              return !!document.querySelector('[data-markdown]')
            },
          },
          {
            src: 'plugin/zoom-js/zoom.js',
            async: true,
            condition: function () {
              return !!document.body.classList
            },
          },
          {
            src: 'plugin/notes/notes.js',
            async: true,
            condition: function () {
              return !!document.body.classList
            },
          },
        ],
      })
    </script>
  </body>
</html>
